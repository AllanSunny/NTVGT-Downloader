const childProcess = require('child_process');
const fs = require("fs");
const util = require("./index");
const pLimit = require("p-limit");

/**
 * This class holds information for and executes individual song downloads.
 */
class DownloadJob {
    constructor(song) {
        this.song = song;
        //Stores the running youtube download, if any
        this.runningDownload = undefined;
        //If an attempt is made to abort a running download
        this.killed = false;
    }

    /**
     * Download and trim the audio file for the song.
     * @returns {Promise} Resolves when the download completes.
     */
    async execute() {
        //First make sure the song file doesn't already exist
        let alreadyExists = await util.checkFileOrDirExistence(this.song.getFilePath());

        return new Promise(async (resolve, reject) => {
            if (alreadyExists) {
                console.log(`*${this.song.getName()} - ${this.song.getGameName()} is already downloaded!*`);
                resolve();
            } else {
                try {
                    await downloadSong(this);
                    await processSong(this);
                    await deleteTemp(this);
                    console.log(`*Completed download of "${this.song.getName()} - ${this.song.getGameName()}"!*`);
                    resolve();
                } catch (error) {
                    reject(error);
                }
            }
        });
    }

    /**
     * Cancel this DownloadJob, if it has not already finished
     * downloading audio from a Youtube video.
     */
    killDownload() {
        if (this.runningDownload) {
            this.killed = true;
            this.runningDownload.kill();
        }
    }
}

/**
 * A "cancellable task" that manages all the running downloads.
 */
class DownloadJobQueue {
    /**
     * Generate a queue of downloads to be executed.
     * @param gameManager The object where all the songs are stored.
     * @param {number} [limit=2] The max number of concurrent downloads allowed.
     */
    constructor(gameManager, limit) {
        this.queue = []; //Queue of download job execution promises to be fulfilled
        let concurrency;
        limit ? concurrency = limit : concurrency = "2";
        this.limiter = pLimit(parseInt(concurrency));

        this.jobs = []; //Instances of DownloadJobs
        this.gameManager = gameManager;
        //If an attempt is made to abort all running downloads
        this.killed = false;
    }

    /**
     * Start executing all the downloads in the queue.
     * @param destination The root directory to store all files in.
     * @returns {Promise} Resolves once the queue has cleared, on
     *      all downloads completing/aborting.
     */
    execute(destination) {
        return new Promise(async (resolve) => {
            this.gameManager.setDestination(destination);
            this.gameManager.queueDownloads(this);

            //Errors will be handled by individual downloads
            await Promise.all(this.queue)
                .then(() => {
                    if (this.killed) {
                        console.log("Download process aborted!");
                    } else {
                        console.log("Downloads complete!");
                    }
                    resolve();
                });
        });
    }

    /**
     * Abort all downloads, in progress and queued.
     * @returns {Promise} Resolves once all downloads have been aborted.
     */
    killProcesses() {
        if (this.limiter.pendingCount !== 0) {
            this.limiter.clearQueue();
        }

        return new Promise((resolve) => {
            this.killed = true;
            for (let job of this.jobs) {
                job.killDownload();
            }
            resolve();
        });
    }

    /**
     * Clean up temporary download files generated by youtube-dl
     * (used on download abortion).
     * @returns {Promise} Resolves once all files have been cleaned.
     */
    cleanUp() {
        return new Promise((resolve) => {
            this.gameManager.cleanUpDownloads();
            resolve();
        });
    }
}


/**
 * Download a song's audio from its associated Youtube video.
 * @param job The DownloadJob containing the song object.
 * @returns {Promise} Resolves once the download completes, rejects
 *      upon an error or abortion.
 */
function downloadSong(job) {
    return new Promise(async (resolve, reject) => {
        console.log(`Downloading audio for "${job.song.getName()} - ${job.song.getGameName()}"...`);

        job.runningDownload = childProcess.execFile('./util/downloadutils/youtube-dl.exe',
            ['-o', `${job.song.getFilePath()} (temp)`,
                '--config-location', './util/downloadutils/ytdlconfig.txt',
                job.song.getYTLink()],
            (error, stdout) => {
                if (error && !job.killed) {
                    console.error(`An error occurred while trying to download "${job.song.getName()} - ${job.song.getGameName()}".`);
                    reject(error);
                } else if (error && job.killed) {
                    reject(`The download for "${job.song.getName()} - ${job.song.getGameName()}" was aborted.`);
                } else {
                    console.log(stdout);
                    console.log(`Downloaded audio for "${job.song.getName()} - ${job.song.getGameName()}"!`);
                    job.runningDownload = undefined;
                    resolve();
                }
            });
    });
}

/**
 * Trim the downloaded file and convert it to mp3 format. This processing
 * runs through FFMPEG.
 * @param job The DownloadJob containing the song object.
 * @returns {Promise} Resolves once the process finishes.
 */
function processSong(job) {
    return new Promise(resolve => {
        console.log(`Processing audio for "${job.song.getName()} - ${job.song.getGameName()}"...`);

        childProcess.execFile('./util/downloadutils/ffmpeg.exe',
            ['-hide_banner', '-y',
                '-loglevel', 'panic',
                '-i', `${job.song.getFilePath()} (temp)`,
                '-ss', job.song.getStartTime(), '-t', job.song.getDuration(),
                '-c:v', 'copy', '-c:a', 'libmp3lame',
                '-q:a', '2', `${job.song.getFilePath()}`],
            () => {
            console.log(`Processed audio for "${job.song.getName()} - ${job.song.getGameName()}"!`);
            resolve();
        });
    });
}

/**
 * Delete the temp (full-length audio) file downloaded earlier.
 * @param job The DownloadJob containing the song object.
 * @returns {Promise} Resolves once the process finishes.
 */
function deleteTemp(job) {
    return new Promise(resolve => {
        console.log(`Deleting temporary file for "${job.song.getName()} - ${job.song.getGameName()}"...`);
        fs.unlink(`${job.song.getFilePath()} (temp)`, resolve);
    });
}

module.exports = {
    DownloadJob,
    DownloadJobQueue,
};